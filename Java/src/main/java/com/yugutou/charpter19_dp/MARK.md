# 路径问题


# 最长递增子序列 LIS问题
1. 动态规划，相当于两层遍历，每次找比当前值小的数的个数。
2. 使用贪心+二分查找优化
用数组保存长度为len的子序列的最小元素，通过二分查找小于当前nums[i]的最后一个元素

# 最长公共子序列 LCS问题
动态规划
使用空格补全第一个位置，初始化就很方便，要注意最后减1。
比较s1[i] 和 s2[j]的关系
s1[i] == s2[j] dp[i][j] = dp[i - 1][j - 1] + 1
s1[i] != s2[j] dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1])
