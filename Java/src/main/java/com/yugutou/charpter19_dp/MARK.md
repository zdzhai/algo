# 路径问题

有特定起点（起点），有明确且有限的移动方向（转移状态），求解所有状态中的最优值。

## 记忆化搜索
把每一步得到的结果都记下来，再用到的时候直接返回。爬楼梯问题中保存每一个dp[]值。

> leetcode 1575.统计所有可行路径
> leetcode 416.分割等和子集

# 01背包


# 完全背包

# 最长递增子序列 LIS问题
1. 动态规划，相当于两层遍历，每次找比当前值小的数的个数。
2. 使用贪心+二分查找优化
用数组保存长度为len的子序列的最小元素，通过二分查找小于当前nums[i]的最后一个元素

# 最长公共子序列 LCS问题
动态规划
使用空格补全第一个位置，初始化就很方便，要注意最后减1。
比较s1[i] 和 s2[j]的关系
s1[i] == s2[j] dp[i][j] = dp[i - 1][j - 1] + 1
s1[i] != s2[j] dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1])
